"""
Tabu Search

"""

import copy
from random import Random
import numpy as np
import time

seed = 12345
myPRNG = Random(seed)

#initialize variables for general knapsack problem
values = []
weights = []

n = 500
maxWeight = 4*n

#initialize tabu search settings
stopping_criterion = True
tabu_tenure = 10
memory = {} #short-term memory


"""
Initialize Knapsack problem
Define standard functions for knapsack problem
"""

def create_random_instance():
    #create values
    for i in xrange(0,n):
        values.append(myPRNG.randint(10,100))

    #create weights
    for i in xrange(0,n):
        weights.append(myPRNG.randint(5,15))

    #initialize starting current solution
    x_curr = []

    for i in xrange(0,n):              
        if myPRNG.random() < 0.7:
            x_curr.append(0)
        else:
            x_curr.append(1)   
    return x_curr

def calc_weight(x):
    a=np.array(x)
    c=np.array(weights)
    totalWeight = np.dot(a,c)    #compute the weight value of the knapsack selection
    return totalWeight

def evaluate(x):

    a=np.array(x)
    b=np.array(values)

    value = np.dot(a,b)          
    totalWeight = calc_weight(x) 

    if totalWeight > maxWeight:
        value =  maxWeight - totalWeight

    return value


"""
Then define functions for Tabu Search
And Path-Relinking
"""
#function to create a 1-flip neighborhood of solution x
def get_neighbors(solution):
    nbrhood = []     

    for i in xrange(0,n):
        nbrhood.append(solution[:])
        if nbrhood[i][i] == 1:
            nbrhood[i][i] = 0
        else:
            nbrhood[i][i] = 1

    return nbrhood    

#Find and return list of candidate moves, a subset of the neighborhood of current solution
#returns a list of tuples, each tuple is structured as (Solution, Index Flipped)

def get_candidate_moves(current):
    candidates = []     

    for i in xrange(0, n):    
        if i not in memory.keys():
            candidates.append((current[:], i))
            lastIndex = len(candidates) - 1
            if candidates[lastIndex][0][i] == 1:
                candidates[lastIndex][0][i] = 0
            else:
                candidates[lastIndex][0][i] = 1

    return candidates 


#return the candidate in the list that returns the extended cost function
#The method can handle two solution_list structures 
def min_cost_solution(solution_list):
    
    #solution_list is a list of tuples structured as (Solution, Index Flipped)
    if len(solution_list[0]) == 2:
        #initialize values
        bestsol = solution_list[0][0]
        bestval = evaluate(solution_list[0][0])
        flipped_index = 0
    
        #check for best solution
        for sol in solution_list:
            val = evaluate(sol[0])
            if val > bestval:
                bestsol, bestval, flipped_index = sol[0], val, sol[1]
    
        return bestsol, flipped_index
    
    #otherwise solution_list is a list of solution-lists
    else:
        #initialize values
        bestsol = solution_list[0]
        bestval = evaluate(solution_list[0])
            
        #check for best solution
        for sol in solution_list:
            val = evaluate(sol)
            if val > bestval:
                bestsol, bestval= sol, val
    
        return bestsol
        

#index of flipped position of the new solution to the tabu memory and updates the tabu memory
def update_tabu_memory(current_flipped_index):    

    #update short-term memory
    for key in memory.keys():

        #If the memory, is greater than 1, decrement the memory by 1
        if memory[key] > 1:
            memory[key] = memory[key] - 1

        #If the memory for the key equals 1, remove the key from the dictionary
        else:
            memory.pop(key) 
            
    # Make new solution tabu-active
    memory[current_flipped_index] = tabu_tenure


#This method checks whether two solutions are the same and returns a boolean indicating the result
def same_solution(sol1, sol2):
    for i in xrange(len(sol1)):
        #if the elements at index i are not the same, the solutions are not the same
        if sol1[i] != sol2[i]:
            return False
   
    #Otherwise the solutions are the same
    return True

def get_path_relink_moves(initiatingSol, guidingSol):
    candidate_moves = []
    
    for i in xrange(len(initiatingSol)):
        #if the elements at index i are not the same, flip the index i of initiatingSol and add to the candidate moves
        if initiatingSol[i] != guidingSol[i]:
            newSol = initiatingSol[:]
            newSol[i] = guidingSol[i]
            candidate_moves.append(newSol)
    
    return candidate_moves
        

"""
Implement Tabu Search
with Path Relinking
"""

Inf = 100000000000 #simulate infinity

Best_Solution = None  #global best solution
Best_Value = None     #value of global best solution

bestSol_currIt = None #best solution of the current iteration
bestVal_currIt = None #value of best solution of the current iteration
worstSol_currIt = None #worst solution of the current iteration
worstVal_currIt = Inf #value of worst solution of the current iteration

iterations = 1 #tally number of iterations
relink_iteration = 1 #tally number of iterations between relinking
maxRelinkIt = 100    #Max number of iterations between relinking
startTime = time.time()
timeLimit = 120

current = create_random_instance()

while stopping_criterion: 
    candidate_moves = get_candidate_moves(current) #list of tuples (Solution, flipped index)
    current = min_cost_solution(candidate_moves) #tuple (Solution, flipped index)
    update_tabu_memory(current[1])
    current = current[0] #extract list from current and assign to current

    #check if new solution is better than the best (global) solution found so far
    currentval = evaluate(current)
    if currentval > Best_Value:
        Best_Solution, Best_Value = current, currentval    
    
    #check if new solution is better than the best solution found during the iteration 
    #or worse than the worst solution found during the iteration so far
    if currentval > bestVal_currIt:
        bestSol_currIt, bestVal_currIt = current, currentval    
    if currentval < worstVal_currIt:
        worstSol_currIt, worstVal_currIt = current, currentval    
    
    #Path-Relinking
    if relink_iteration >= maxRelinkIt and time.time() - startTime > timeLimit/2:
        
        newSol = worstSol_currIt
        newVal = worstVal_currIt
        
        print "\nPath-Relinking", iterations
        print "Best Solution:", bestVal_currIt, bestSol_currIt
        print "Worst Solution:", worstVal_currIt, worstSol_currIt
        
        #while the initiating solution (newSol) and the guiding solution(bestSol) are different, continue the loop
        while same_solution(newSol, bestSol_currIt) == False:
            
            #delta(x,y)
            #evaluate all 1-flip moves from the initiating solution to the guiding solution
            relinkMoves = get_path_relink_moves(newSol, bestSol_currIt)
            
            #make best move
            newSol = min_cost_solution(relinkMoves)
            #newSol = newSol[0]
            
            #get value of best move and compare to global optimum
            newVal= evaluate(current)
            if newVal > Best_Value:
                current, currentVal = newSol, newVal # set new best solution as the current solution
                Best_Solution, Best_Value = newSol, newVal # store the new best solution as a global best
                print "Global best found:", newVal, newSol
                
        #reset variables
        bestSol_currIt = None #best solution of the current iteration
        bestVal_currIt = None #value of best solution of the current iteration
        worstSol_currIt = None #worst solution of the current iteration
        worstVal_currIt = Inf #value of worst solution of the current iteration   
        relink_iteration = 1
    else:
        relink_iteration += 1
    
    #update stopping criterion if met
    if time.time() - startTime > timeLimit:              
        stopping_criterion = False
    else:
        iterations += 1

print "The best solution found is: ", Best_Solution 
print "Number of iterations: ", iterations
print "With value: ", Best_Value
print "The weight is: ", calc_weight(Best_Solution)
